{"ast":null,"code":"import { isArray, formatNum } from '../core/Util';\n/*\r\n * @class Point\r\n * @aka L.Point\r\n *\r\n * Represents a point with `x` and `y` coordinates in pixels.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var point = L.point(200, 300);\r\n * ```\r\n *\r\n * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n *\r\n * ```js\r\n * map.panBy([200, 300]);\r\n * map.panBy(L.point(200, 300));\r\n * ```\r\n *\r\n * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n * which means new classes can't inherit from it, and new methods\r\n * can't be added to it with the `include` function.\r\n */\n\nexport function Point(x, y, round) {\n  // @property x: Number; The `x` coordinate of the point\n  this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point\n\n  this.y = round ? Math.round(y) : y;\n}\n\nvar trunc = Math.trunc || function (v) {\n  return v > 0 ? Math.floor(v) : Math.ceil(v);\n};\n\nPoint.prototype = {\n  // @method clone(): Point\n  // Returns a copy of the current point.\n  clone: function clone() {\n    return new Point(this.x, this.y);\n  },\n  // @method add(otherPoint: Point): Point\n  // Returns the result of addition of the current and the given points.\n  add: function add(point) {\n    // non-destructive, returns a new point\n    return this.clone()._add(toPoint(point));\n  },\n  _add: function _add(point) {\n    // destructive, used directly for performance in situations where it's safe to modify existing point\n    this.x += point.x;\n    this.y += point.y;\n    return this;\n  },\n  // @method subtract(otherPoint: Point): Point\n  // Returns the result of subtraction of the given point from the current.\n  subtract: function subtract(point) {\n    return this.clone()._subtract(toPoint(point));\n  },\n  _subtract: function _subtract(point) {\n    this.x -= point.x;\n    this.y -= point.y;\n    return this;\n  },\n  // @method divideBy(num: Number): Point\n  // Returns the result of division of the current point by the given number.\n  divideBy: function divideBy(num) {\n    return this.clone()._divideBy(num);\n  },\n  _divideBy: function _divideBy(num) {\n    this.x /= num;\n    this.y /= num;\n    return this;\n  },\n  // @method multiplyBy(num: Number): Point\n  // Returns the result of multiplication of the current point by the given number.\n  multiplyBy: function multiplyBy(num) {\n    return this.clone()._multiplyBy(num);\n  },\n  _multiplyBy: function _multiplyBy(num) {\n    this.x *= num;\n    this.y *= num;\n    return this;\n  },\n  // @method scaleBy(scale: Point): Point\n  // Multiply each coordinate of the current point by each coordinate of\n  // `scale`. In linear algebra terms, multiply the point by the\n  // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\n  // defined by `scale`.\n  scaleBy: function scaleBy(point) {\n    return new Point(this.x * point.x, this.y * point.y);\n  },\n  // @method unscaleBy(scale: Point): Point\n  // Inverse of `scaleBy`. Divide each coordinate of the current point by\n  // each coordinate of `scale`.\n  unscaleBy: function unscaleBy(point) {\n    return new Point(this.x / point.x, this.y / point.y);\n  },\n  // @method round(): Point\n  // Returns a copy of the current point with rounded coordinates.\n  round: function round() {\n    return this.clone()._round();\n  },\n  _round: function _round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  },\n  // @method floor(): Point\n  // Returns a copy of the current point with floored coordinates (rounded down).\n  floor: function floor() {\n    return this.clone()._floor();\n  },\n  _floor: function _floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  },\n  // @method ceil(): Point\n  // Returns a copy of the current point with ceiled coordinates (rounded up).\n  ceil: function ceil() {\n    return this.clone()._ceil();\n  },\n  _ceil: function _ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  },\n  // @method trunc(): Point\n  // Returns a copy of the current point with truncated coordinates (rounded towards zero).\n  trunc: function trunc() {\n    return this.clone()._trunc();\n  },\n  _trunc: function _trunc() {\n    this.x = trunc(this.x);\n    this.y = trunc(this.y);\n    return this;\n  },\n  // @method distanceTo(otherPoint: Point): Number\n  // Returns the cartesian distance between the current and the given points.\n  distanceTo: function distanceTo(point) {\n    point = toPoint(point);\n    var x = point.x - this.x,\n        y = point.y - this.y;\n    return Math.sqrt(x * x + y * y);\n  },\n  // @method equals(otherPoint: Point): Boolean\n  // Returns `true` if the given point has the same coordinates.\n  equals: function equals(point) {\n    point = toPoint(point);\n    return point.x === this.x && point.y === this.y;\n  },\n  // @method contains(otherPoint: Point): Boolean\n  // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\n  contains: function contains(point) {\n    point = toPoint(point);\n    return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);\n  },\n  // @method toString(): String\n  // Returns a string representation of the point for debugging purposes.\n  toString: function toString() {\n    return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';\n  }\n}; // @factory L.point(x: Number, y: Number, round?: Boolean)\n// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\n// @alternative\n// @factory L.point(coords: Number[])\n// Expects an array of the form `[x, y]` instead.\n// @alternative\n// @factory L.point(coords: Object)\n// Expects a plain object of the form `{x: Number, y: Number}` instead.\n\nexport function toPoint(x, y, round) {\n  if (x instanceof Point) {\n    return x;\n  }\n\n  if (isArray(x)) {\n    return new Point(x[0], x[1]);\n  }\n\n  if (x === undefined || x === null) {\n    return x;\n  }\n\n  if (typeof x === 'object' && 'x' in x && 'y' in x) {\n    return new Point(x.x, x.y);\n  }\n\n  return new Point(x, y, round);\n}","map":{"version":3,"sources":["C:/Users/vtito/PycharmProjects/weather_app/weather_app/node_modules/leaflet/src/geometry/Point.js"],"names":["isArray","formatNum","Point","x","y","round","Math","trunc","v","floor","ceil","prototype","clone","add","point","_add","toPoint","subtract","_subtract","divideBy","num","_divideBy","multiplyBy","_multiplyBy","scaleBy","unscaleBy","_round","_floor","_ceil","_trunc","distanceTo","sqrt","equals","contains","abs","toString","undefined"],"mappings":"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","sourcesContent":["import {isArray, formatNum} from '../core/Util';\r\n\r\n/*\r\n * @class Point\r\n * @aka L.Point\r\n *\r\n * Represents a point with `x` and `y` coordinates in pixels.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * var point = L.point(200, 300);\r\n * ```\r\n *\r\n * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:\r\n *\r\n * ```js\r\n * map.panBy([200, 300]);\r\n * map.panBy(L.point(200, 300));\r\n * ```\r\n *\r\n * Note that `Point` does not inherit from Leaflet's `Class` object,\r\n * which means new classes can't inherit from it, and new methods\r\n * can't be added to it with the `include` function.\r\n */\r\n\r\nexport function Point(x, y, round) {\r\n\t// @property x: Number; The `x` coordinate of the point\r\n\tthis.x = (round ? Math.round(x) : x);\r\n\t// @property y: Number; The `y` coordinate of the point\r\n\tthis.y = (round ? Math.round(y) : y);\r\n}\r\n\r\nvar trunc = Math.trunc || function (v) {\r\n\treturn v > 0 ? Math.floor(v) : Math.ceil(v);\r\n};\r\n\r\nPoint.prototype = {\r\n\r\n\t// @method clone(): Point\r\n\t// Returns a copy of the current point.\r\n\tclone: function () {\r\n\t\treturn new Point(this.x, this.y);\r\n\t},\r\n\r\n\t// @method add(otherPoint: Point): Point\r\n\t// Returns the result of addition of the current and the given points.\r\n\tadd: function (point) {\r\n\t\t// non-destructive, returns a new point\r\n\t\treturn this.clone()._add(toPoint(point));\r\n\t},\r\n\r\n\t_add: function (point) {\r\n\t\t// destructive, used directly for performance in situations where it's safe to modify existing point\r\n\t\tthis.x += point.x;\r\n\t\tthis.y += point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method subtract(otherPoint: Point): Point\r\n\t// Returns the result of subtraction of the given point from the current.\r\n\tsubtract: function (point) {\r\n\t\treturn this.clone()._subtract(toPoint(point));\r\n\t},\r\n\r\n\t_subtract: function (point) {\r\n\t\tthis.x -= point.x;\r\n\t\tthis.y -= point.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method divideBy(num: Number): Point\r\n\t// Returns the result of division of the current point by the given number.\r\n\tdivideBy: function (num) {\r\n\t\treturn this.clone()._divideBy(num);\r\n\t},\r\n\r\n\t_divideBy: function (num) {\r\n\t\tthis.x /= num;\r\n\t\tthis.y /= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method multiplyBy(num: Number): Point\r\n\t// Returns the result of multiplication of the current point by the given number.\r\n\tmultiplyBy: function (num) {\r\n\t\treturn this.clone()._multiplyBy(num);\r\n\t},\r\n\r\n\t_multiplyBy: function (num) {\r\n\t\tthis.x *= num;\r\n\t\tthis.y *= num;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method scaleBy(scale: Point): Point\r\n\t// Multiply each coordinate of the current point by each coordinate of\r\n\t// `scale`. In linear algebra terms, multiply the point by the\r\n\t// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)\r\n\t// defined by `scale`.\r\n\tscaleBy: function (point) {\r\n\t\treturn new Point(this.x * point.x, this.y * point.y);\r\n\t},\r\n\r\n\t// @method unscaleBy(scale: Point): Point\r\n\t// Inverse of `scaleBy`. Divide each coordinate of the current point by\r\n\t// each coordinate of `scale`.\r\n\tunscaleBy: function (point) {\r\n\t\treturn new Point(this.x / point.x, this.y / point.y);\r\n\t},\r\n\r\n\t// @method round(): Point\r\n\t// Returns a copy of the current point with rounded coordinates.\r\n\tround: function () {\r\n\t\treturn this.clone()._round();\r\n\t},\r\n\r\n\t_round: function () {\r\n\t\tthis.x = Math.round(this.x);\r\n\t\tthis.y = Math.round(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method floor(): Point\r\n\t// Returns a copy of the current point with floored coordinates (rounded down).\r\n\tfloor: function () {\r\n\t\treturn this.clone()._floor();\r\n\t},\r\n\r\n\t_floor: function () {\r\n\t\tthis.x = Math.floor(this.x);\r\n\t\tthis.y = Math.floor(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method ceil(): Point\r\n\t// Returns a copy of the current point with ceiled coordinates (rounded up).\r\n\tceil: function () {\r\n\t\treturn this.clone()._ceil();\r\n\t},\r\n\r\n\t_ceil: function () {\r\n\t\tthis.x = Math.ceil(this.x);\r\n\t\tthis.y = Math.ceil(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method trunc(): Point\r\n\t// Returns a copy of the current point with truncated coordinates (rounded towards zero).\r\n\ttrunc: function () {\r\n\t\treturn this.clone()._trunc();\r\n\t},\r\n\r\n\t_trunc: function () {\r\n\t\tthis.x = trunc(this.x);\r\n\t\tthis.y = trunc(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// @method distanceTo(otherPoint: Point): Number\r\n\t// Returns the cartesian distance between the current and the given points.\r\n\tdistanceTo: function (point) {\r\n\t\tpoint = toPoint(point);\r\n\r\n\t\tvar x = point.x - this.x,\r\n\t\t    y = point.y - this.y;\r\n\r\n\t\treturn Math.sqrt(x * x + y * y);\r\n\t},\r\n\r\n\t// @method equals(otherPoint: Point): Boolean\r\n\t// Returns `true` if the given point has the same coordinates.\r\n\tequals: function (point) {\r\n\t\tpoint = toPoint(point);\r\n\r\n\t\treturn point.x === this.x &&\r\n\t\t       point.y === this.y;\r\n\t},\r\n\r\n\t// @method contains(otherPoint: Point): Boolean\r\n\t// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).\r\n\tcontains: function (point) {\r\n\t\tpoint = toPoint(point);\r\n\r\n\t\treturn Math.abs(point.x) <= Math.abs(this.x) &&\r\n\t\t       Math.abs(point.y) <= Math.abs(this.y);\r\n\t},\r\n\r\n\t// @method toString(): String\r\n\t// Returns a string representation of the point for debugging purposes.\r\n\ttoString: function () {\r\n\t\treturn 'Point(' +\r\n\t\t        formatNum(this.x) + ', ' +\r\n\t\t        formatNum(this.y) + ')';\r\n\t}\r\n};\r\n\r\n// @factory L.point(x: Number, y: Number, round?: Boolean)\r\n// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.\r\n\r\n// @alternative\r\n// @factory L.point(coords: Number[])\r\n// Expects an array of the form `[x, y]` instead.\r\n\r\n// @alternative\r\n// @factory L.point(coords: Object)\r\n// Expects a plain object of the form `{x: Number, y: Number}` instead.\r\nexport function toPoint(x, y, round) {\r\n\tif (x instanceof Point) {\r\n\t\treturn x;\r\n\t}\r\n\tif (isArray(x)) {\r\n\t\treturn new Point(x[0], x[1]);\r\n\t}\r\n\tif (x === undefined || x === null) {\r\n\t\treturn x;\r\n\t}\r\n\tif (typeof x === 'object' && 'x' in x && 'y' in x) {\r\n\t\treturn new Point(x.x, x.y);\r\n\t}\r\n\treturn new Point(x, y, round);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}